generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DB_CONNECTION_STRING")
  extensions = [citext(schema: "public")]
}

// Each of these tables has a 'meta' field added to it, which takes an optional JSON data object. 
// This is basically to ease development moving forward. Migrating the development database is a snap,
// migrating the staging/demo database is a pain and a half, so if a feature needs a schema change,
// we can use 'meta' to store the data (inefficiently) for now, and refactor during the next big schema update. 
model User {
  id        String   @id @default(cuid())
  email     String   @unique @db.Citext
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  profile   Profile? @relation("UserProfile")
  meta      Json?

  @@index([email, id])
}

model Profile {
  userId                    String                 @id @unique
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  username                  String                 @unique @db.Citext
  bannedUntil               DateTime?
  reasonForBan              String?
  verified                  Boolean
  lastUpdateInstant         DateTime?
  lastLoginInstant          DateTime?
  passwordLastUpdateInstant DateTime?
  memberships               String[]
  comments                  Comment[]              @relation("CommentAuthor")
  reactedComments           CommentReaction[]      @relation("ReactedToComment")
  taggedComments            CommentTag[]           @relation("TaggedComment")
  commentVotes              CommentVote[]          @relation("CommentVoter")
  communities               Community[]            @relation("CommunityCreator")
  hasBanned                 CommunityBan[]         @relation("BanningUser")
  communityBans             CommunityBan[]         @relation("CommunityBan")
  moderates                 CommunityModerators[]  @relation("ModeratesCommunity")
  subscribes                CommunitySubscribers[] @relation("CommunitySubscriber")
  sentMessages              Message[]              @relation("SentMessage")
  receivedMessages          Message[]              @relation("ReceivedMessage")
  posts                     Post[]                 @relation("PostAuthor")
  reactedPosts              PostReaction[]         @relation("ReactedToPost")
  taggedPosts               PostTag[]              @relation("TaggedPost")
  Voter                     PostVote[]             @relation("PostVoter")
  user                      User                   @relation("UserProfile", fields: [userId], references: [id], onDelete: Cascade)
  meta                      Json?

  @@index([username])
}

model Comment {
  id             Int               @id @unique @default(autoincrement())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  text           String
  parentId       Int?
  authorId       String
  isSticked      Boolean           @default(false)
  communityRoute String            @db.Citext
  postId         Int
  author         Profile           @relation("CommentAuthor", fields: [authorId], references: [userId], onDelete: Cascade)
  community      Community         @relation("CommentCommunity", fields: [communityRoute], references: [route], onDelete: Cascade)
  parent         Comment?          @relation("ParentComment", fields: [parentId], references: [id], onDelete: Cascade)
  childComments  Comment[]         @relation("ParentComment")
  post           Post              @relation("CommentPost", fields: [postId], references: [id])
  reactions      CommentReaction[] @relation("CommentHasReaction")
  tags           CommentTag[]      @relation("CommentHasTag")
  votes          CommentVote[]     @relation("CommentVote")
  meta           Json?
}

model CommentVote {
  value     Int
  commentId Int
  comment   Comment @relation("CommentVote", fields: [commentId], references: [id], onDelete: Cascade)
  voterId   String
  voter     Profile @relation("CommentVoter", fields: [voterId], references: [userId], onDelete: Cascade)
  meta      Json?

  @@id([commentId, voterId])
}

model PostVote {
  value   Int
  post    Post    @relation("PostVote", fields: [postId], references: [id], onDelete: Cascade)
  postId  Int
  voter   Profile @relation("PostVoter", fields: [voterId], references: [userId], onDelete: Cascade)
  voterId String
  meta    Json?

  @@id([postId, voterId])
}

model Post {
  id             Int            @id @unique @default(autoincrement())
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  title          String         @db.VarChar(512)
  text           String?
  embeds         String?
  link           String?
  authorId       String
  communityRoute String         @db.Citext
  isSticked      Boolean        @default(false)
  comments       Comment[]      @relation("CommentPost")
  author         Profile        @relation("PostAuthor", fields: [authorId], references: [userId], onDelete: Cascade)
  community      Community      @relation("PostedIn", fields: [communityRoute], references: [route], onDelete: Cascade)
  reactions      PostReaction[] @relation("PostHasReaction")
  tags           PostTag[]      @relation("PostHasTag")
  Voter          PostVote[]     @relation("PostVote")
  meta           Json?
}

model Community {
  route                String                 @id @unique @db.Citext
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  createdById          String
  name                 String                 @unique
  headerImage          String?
  description          String?
  isPublic             Boolean                @default(true)
  comments             Comment[]              @relation("CommentCommunity")
  createdBy            Profile                @relation("CommunityCreator", fields: [createdById], references: [userId], onDelete: Cascade)
  communityBans        CommunityBan[]         @relation("BannedFrom")
  moderators           CommunityModerators[]  @relation("ModeratedCommunity")
  communitySubscribers CommunitySubscribers[] @relation("SubscribedCommunity")
  posts                Post[]                 @relation("PostedIn")
  meta                 Json?

  @@index([name])
}

model CommunityBan {
  id             Int       @id @unique @default(autoincrement())
  communityRoute String    @db.Citext
  bannedUserId   String
  bannedById     String
  banReason      String?
  bannedBy       Profile   @relation("BanningUser", fields: [bannedById], references: [userId], onDelete: Cascade)
  bannedUser     Profile   @relation("CommunityBan", fields: [bannedUserId], references: [userId], onDelete: Cascade)
  community      Community @relation("BannedFrom", fields: [communityRoute], references: [route], onDelete: Cascade)
  meta           Json?
}

model CommunityModerators {
  id             Int       @id @unique @default(autoincrement())
  communityRoute String    @db.Citext
  moderatorId    String
  community      Community @relation("ModeratedCommunity", fields: [communityRoute], references: [route], onDelete: Cascade)
  moderator      Profile   @relation("ModeratesCommunity", fields: [moderatorId], references: [userId], onDelete: Cascade)
  meta           Json?
}

model CommunitySubscribers {
  id             Int       @id @unique @default(autoincrement())
  communityRoute String    @db.Citext
  subscriberId   String
  community      Community @relation("SubscribedCommunity", fields: [communityRoute], references: [route], onDelete: Cascade)
  subscriber     Profile   @relation("CommunitySubscriber", fields: [subscriberId], references: [userId], onDelete: Cascade)
  meta           Json?
}

model Message {
  id            Int       @id @unique @default(autoincrement())
  fromId        String
  toId          String
  parentId      Int?
  text          String
  createdAt     DateTime  @default(now())
  read          Boolean   @default(false)
  from          Profile   @relation("SentMessage", fields: [fromId], references: [userId], onDelete: Cascade)
  parent        Message?  @relation("ParentMessage", fields: [parentId], references: [id], onDelete: Cascade)
  childMessages Message[] @relation("ParentMessage")
  to            Profile   @relation("ReceivedMessage", fields: [toId], references: [userId], onDelete: Cascade)
  meta          Json?
}

model Reaction {
  name     String            @id @unique
  comments CommentReaction[] @relation("CommentReactionType")
  posts    PostReaction[]    @relation("PostReactionType")
  meta     Json?
}

model Tag {
  name       String       @id @unique
  CommentTag CommentTag[] @relation("CommentTagIdentity")
  PostTag    PostTag[]    @relation("PostTagIdentity")
  meta       Json?
}

model PostTag {
  id       Int     @id @unique @default(autoincrement())
  postId   Int
  tagName  String
  taggerId String
  post     Post    @relation("PostHasTag", fields: [postId], references: [id], onDelete: Cascade)
  tag      Tag     @relation("PostTagIdentity", fields: [tagName], references: [name], onDelete: Cascade)
  tagger   Profile @relation("TaggedPost", fields: [taggerId], references: [userId], onDelete: Cascade)
  meta     Json?
}

model CommentTag {
  id        Int     @id @unique @default(autoincrement())
  comment   Comment @relation("CommentHasTag", fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  tagName   String
  taggerId  String
  tag       Tag     @relation("CommentTagIdentity", fields: [tagName], references: [name], onDelete: Cascade)
  tagger    Profile @relation("TaggedComment", fields: [taggerId], references: [userId], onDelete: Cascade)
  meta      Json?
}

model PostReaction {
  id           Int      @id @unique @default(autoincrement())
  reactionName String
  postId       Int
  reactorId    String
  post         Post     @relation("PostHasReaction", fields: [postId], references: [id], onDelete: Cascade)
  reaction     Reaction @relation("PostReactionType", fields: [reactionName], references: [name], onDelete: Cascade)
  reactor      Profile  @relation("ReactedToPost", fields: [reactorId], references: [userId], onDelete: Cascade)
  meta         Json?
}

model CommentReaction {
  id           Int      @id @unique @default(autoincrement())
  reactionName String
  commentId    Int
  reactorId    String
  comment      Comment  @relation("CommentHasReaction", fields: [commentId], references: [id], onDelete: Cascade)
  reaction     Reaction @relation("CommentReactionType", fields: [reactionName], references: [name], onDelete: Cascade)
  reactor      Profile  @relation("ReactedToComment", fields: [reactorId], references: [userId], onDelete: Cascade)
  meta         Json?
}
